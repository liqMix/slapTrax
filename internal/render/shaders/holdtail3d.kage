//kage:unit pixels
package main

// Hold note tail shader uniforms (3D version)
var Progress float         // Current note progress (not used for tail)
var Point1X float          // First point of track shape
var Point1Y float
var Point2X float          // Second point (corner/center)
var Point2Y float
var Point3X float          // Third point of track shape
var Point3Y float
var CenterX float          // Center vanishing point X
var CenterY float          // Center vanishing point Y
var Width float            // Base width
var WidthScale float       // Width multiplier
var ColorR float           // Note color red
var ColorG float           // Note color green
var ColorB float           // Note color blue
var ColorA float           // Note color alpha
var Glow float             // Glow intensity
var Solo float             // 1.0 if solo, 0.0 otherwise
var TimeMs float           // Time in milliseconds for animations
var HoldStartProgress float // Where hold starts (0.0-1.0)
var HoldEndProgress float   // Where hold ends (0.0-1.0)
var WasHit float           // 1.0 if hit, 0.0 otherwise
var WasReleased float      // 1.0 if released, 0.0 otherwise
var IsActive float         // 1.0 if currently active (being held), 0.0 otherwise
var BPM float              // Song BPM for oscillation sync
var FadeInThreshold float  // Progress below which notes are invisible
var FadeOutThreshold float // Progress above which notes are fully visible

func Fragment(position vec4, texCoord vec2, color vec4) vec4 {
    fragX := position.x
    fragY := position.y
    
    // Calculate start and end track positions for continuous connection
    startP1X := CenterX + (Point1X - CenterX) * HoldStartProgress
    startP1Y := CenterY + (Point1Y - CenterY) * HoldStartProgress
    startP2X := CenterX + (Point2X - CenterX) * HoldStartProgress
    startP2Y := CenterY + (Point2Y - CenterY) * HoldStartProgress  
    startP3X := CenterX + (Point3X - CenterX) * HoldStartProgress
    startP3Y := CenterY + (Point3Y - CenterY) * HoldStartProgress
    
    endP1X := CenterX + (Point1X - CenterX) * HoldEndProgress
    endP1Y := CenterY + (Point1Y - CenterY) * HoldEndProgress
    endP2X := CenterX + (Point2X - CenterX) * HoldEndProgress
    endP2Y := CenterY + (Point2Y - CenterY) * HoldEndProgress
    endP3X := CenterX + (Point3X - CenterX) * HoldEndProgress  
    endP3Y := CenterY + (Point3Y - CenterY) * HoldEndProgress
    
    // NO STATIC OSCILLATION - we'll do it dynamically per fragment!
    
    // Create solid connections for both track segments
    // Segment 1: swept area from (startP1->startP2) to (endP1->endP2)
    // Segment 2: swept area from (startP2->startP3) to (endP2->endP3)
    
    // Calculate which progress point this fragment corresponds to first
    // Find center line of the hold to determine fragment's position along it
    centerStartX := (startP1X + startP2X + startP3X) / 3.0
    centerStartY := (startP1Y + startP2Y + startP3Y) / 3.0
    centerEndX := (endP1X + endP2X + endP3X) / 3.0
    centerEndY := (endP1Y + endP2Y + endP3Y) / 3.0
    
    // Project fragment onto center line to find its progress (0.0 to 1.0)
    holdDirX := centerEndX - centerStartX
    holdDirY := centerEndY - centerStartY
    holdLength := sqrt(holdDirX*holdDirX + holdDirY*holdDirY)
    
    var progressAlongHold float = 0.5 // Default middle
    if holdLength > 0.1 {
        holdDirX /= holdLength
        holdDirY /= holdLength
        toFragX := fragX - centerStartX
        toFragY := fragY - centerStartY
        projection := toFragX*holdDirX + toFragY*holdDirY
        projection = max(0.0, min(holdLength, projection))
        progressAlongHold = projection / holdLength
    }
    
    // APPLY OSCILLATION based on fragment's position along hold!
    var oscillatedStartP1X, oscillatedStartP1Y float = startP1X, startP1Y
    var oscillatedStartP2X, oscillatedStartP2Y float = startP2X, startP2Y
    var oscillatedStartP3X, oscillatedStartP3Y float = startP3X, startP3Y
    var oscillatedEndP1X, oscillatedEndP1Y float = endP1X, endP1Y
    var oscillatedEndP2X, oscillatedEndP2Y float = endP2X, endP2Y
    var oscillatedEndP3X, oscillatedEndP3Y float = endP3X, endP3Y
    
    // SOUND WAVE PROPAGATION - only when hold is active
    // Use IsActive for reactivated notes that may not have WasHit set
    if IsActive > 0.5 || (WasHit > 0.5 && WasReleased < 0.5) {
        // Calculate BPM-based wave speed
        beatsPerSecond := BPM / 60.0
        waveSpeed := TimeMs * 0.001 * beatsPerSecond * 6.28318 // Radians per second
        
        // Sound wave parameters
        wavelength := 4.0 // Creates ~2-3 waves along typical hold length
        amplitude := 10.0 // Controlled oscillation amplitude
        
        // Calculate wave phase for this fragment's position along the hold
        // Wave travels from start (0.0) to end (1.0) of hold
        wavePhase := waveSpeed * 2.0 - progressAlongHold * wavelength
        
        // Calculate oscillation for this specific position
        waveOscillation := sin(wavePhase) * amplitude
        
        // Apply the same oscillation to all track points (they move as a unit)
        oscillatedStartP1X += waveOscillation
        oscillatedStartP2X += waveOscillation
        oscillatedStartP3X += waveOscillation
        oscillatedEndP1X += waveOscillation
        oscillatedEndP2X += waveOscillation
        oscillatedEndP3X += waveOscillation
    }
    
    // Now find distance using oscillated geometry
    distToSweptSeg1 := distanceToSweptSegment(fragX, fragY, oscillatedStartP1X, oscillatedStartP1Y, oscillatedStartP2X, oscillatedStartP2Y, oscillatedEndP1X, oscillatedEndP1Y, oscillatedEndP2X, oscillatedEndP2Y)
    distToSweptSeg2 := distanceToSweptSegment(fragX, fragY, oscillatedStartP2X, oscillatedStartP2Y, oscillatedStartP3X, oscillatedStartP3Y, oscillatedEndP2X, oscillatedEndP2Y, oscillatedEndP3X, oscillatedEndP3Y)
    
    minDist := min(distToSweptSeg1, distToSweptSeg2)
    
    // Use the progress we calculated earlier
    currentProgress := HoldStartProgress + (HoldEndProgress - HoldStartProgress) * progressAlongHold
    
    // Calculate tail width (thinner than regular notes)
    baseWidth := Width * WidthScale * currentProgress * 2.0 // Same base as regular notes
    tailWidth := baseWidth * 0.4 // 40% width for thin tail
    halfWidth := tailWidth * 0.5
    
    // Distance-based alpha for anti-aliasing
    alpha := 1.0 - smoothstep(halfWidth-0.5, halfWidth+0.5, minDist)
    
    if alpha <= 0.0 {
        return vec4(0)
    }
    
    // Apply fade in/out based on progress
    fadeIntensity := 1.0
    if currentProgress < FadeInThreshold {
        fadeIntensity = 0.0
    } else if currentProgress < FadeOutThreshold {
        fadeRange := FadeOutThreshold - FadeInThreshold
        if fadeRange > 0.0 {
            fadeProgress := (currentProgress - FadeInThreshold) / fadeRange
            fadeIntensity = fadeProgress
        }
    }
    
    // ===== SIMPLIFIED SOUND WAVE EFFECTS =====
    
    // Simple depth effect based on distance to center
    normalizedDist := clamp(minDist / halfWidth, 0.0, 1.0)
    centerBrightness := 1.0 + (1.0 - normalizedDist) * 0.3 // Subtle center highlight
    
    // State-based intensity
    stateIntensity := 1.0
    if WasHit > 0.5 && WasReleased < 0.5 {
        // Active hold - slight brightness boost
        stateIntensity = 1.2
    } else if WasReleased > 0.5 {
        // Released hold - dimmed
        stateIntensity = 0.6
    }
    
    // Simple combined effect
    finalIntensity := centerBrightness * stateIntensity * fadeIntensity
    
    // Apply final color
    finalR := ColorR * finalIntensity
    finalG := ColorG * finalIntensity
    finalB := ColorB * finalIntensity
    
    // Tail is more transparent than head
    tailAlpha := ColorA * alpha * 0.8
    
    finalColor := vec4(finalR, finalG, finalB, tailAlpha)
    
    // Simple glow for active holds
    if WasHit > 0.5 && WasReleased < 0.5 && Glow > 0.0 {
        glowRadius := tailWidth * 1.5
        glowAlpha := Glow * (1.0 - smoothstep(0.0, glowRadius, minDist)) * 0.3
        glowColor := vec4(ColorR, ColorG, ColorB, glowAlpha)
        finalColor = mix(finalColor, glowColor, glowAlpha)
    }
    
    return finalColor
}

// Helper function to calculate distance from point to line segment
func distanceToLineSegment(px, py, ax, ay, bx, by float) float {
    abx := bx - ax
    aby := by - ay
    apx := px - ax
    apy := py - ay
    
    ab2 := abx*abx + aby*aby
    
    if ab2 == 0.0 {
        return sqrt(apx*apx + apy*apy)
    }
    
    t := (apx*abx + apy*aby) / ab2
    t = max(0.0, min(1.0, t))
    
    closestX := ax + t * abx
    closestY := ay + t * aby
    
    dx := px - closestX
    dy := py - closestY
    return sqrt(dx*dx + dy*dy)
}

// Helper function to calculate distance from point to swept segment (quadrilateral)
// Forms a quadrilateral from startA->startB to endA->endB
func distanceToSweptSegment(px, py, startAX, startAY, startBX, startBY, endAX, endAY, endBX, endBY float) float {
    // Calculate distance to all four edges of the quadrilateral and take minimum
    
    // Edge 1: start segment (startA -> startB)
    dist1 := distanceToLineSegment(px, py, startAX, startAY, startBX, startBY)
    
    // Edge 2: end segment (endA -> endB)  
    dist2 := distanceToLineSegment(px, py, endAX, endAY, endBX, endBY)
    
    // Edge 3: left side (startA -> endA)
    dist3 := distanceToLineSegment(px, py, startAX, startAY, endAX, endAY)
    
    // Edge 4: right side (startB -> endB)
    dist4 := distanceToLineSegment(px, py, startBX, startBY, endBX, endBY)
    
    return min(min(dist1, dist2), min(dist3, dist4))
}

// Helper function to find progress along a swept segment
func findProgressOnSweptSegment(px, py, startAX, startAY, startBX, startBY, endAX, endAY, endBX, endBY, startProgress, endProgress float) float {
    // Find the parameter t (0 to 1) along the swept surface that's closest to the point
    // We'll project the point onto the centerline of the swept segment
    
    centerStartX := (startAX + startBX) * 0.5
    centerStartY := (startAY + startBY) * 0.5
    centerEndX := (endAX + endBX) * 0.5
    centerEndY := (endAY + endBY) * 0.5
    
    // Vector along the sweep direction
    sweepDirX := centerEndX - centerStartX
    sweepDirY := centerEndY - centerStartY
    sweepLength := sqrt(sweepDirX*sweepDirX + sweepDirY*sweepDirY)
    
    if sweepLength < 0.001 {
        return startProgress // Very short hold, return start
    }
    
    // Normalize sweep direction
    sweepDirX /= sweepLength
    sweepDirY /= sweepLength
    
    // Project point onto sweep centerline
    toPointX := px - centerStartX
    toPointY := py - centerStartY
    projection := toPointX*sweepDirX + toPointY*sweepDirY
    
    // Clamp to sweep bounds
    projection = max(0.0, min(sweepLength, projection))
    
    // Convert to progress (0 to 1 along the sweep)
    t := projection / sweepLength
    
    // Interpolate between start and end progress
    return startProgress + (endProgress - startProgress) * t
}