//kage:unit pixels
package main

// Lane background shader uniforms
var Point1X float          // First corner of lane
var Point1Y float
var Point2X float          // Second corner
var Point2Y float
var Point3X float          // Third corner
var Point3Y float
var Point4X float          // Fourth corner (if needed)
var Point4Y float
var CenterX float          // Vanishing point X
var CenterY float          // Vanishing point Y
var ColorR float           // Lane color red
var ColorG float           // Lane color green
var ColorB float           // Lane color blue
var IsActive float         // 1.0 if lane is active/pressed, 0.0 otherwise

// Helper function to check if point is inside quadrilateral
func isInsideQuad(px, py, x1, y1, x2, y2, x3, y3, x4, y4 float) bool {
    // Use cross product to check if point is on same side of each edge
    return (cross2D(x2-x1, y2-y1, px-x1, py-y1) >= 0.0) &&
           (cross2D(x3-x2, y3-y2, px-x2, py-y2) >= 0.0) &&
           (cross2D(x4-x3, y4-y3, px-x3, py-y3) >= 0.0) &&
           (cross2D(x1-x4, y1-y4, px-x4, py-y4) >= 0.0)
}

func cross2D(ax, ay, bx, by float) float {
    return ax*by - ay*bx
}

// Calculate distance from center with perspective scaling
func getDepthFactor(px, py, centerX, centerY float) float {
    distX := px - centerX
    distY := py - centerY
    distToCenter := sqrt(distX*distX + distY*distY)
    
    // Normalize by screen diagonal approximation
    maxScreenDist := 800.0
    return clamp(distToCenter / maxScreenDist, 0.0, 1.0)
}

func Fragment(position vec4, texCoord vec2, color vec4) vec4 {
    fragX := position.x
    fragY := position.y
    
    // Check if we're inside the lane bounds
    if !isInsideQuad(fragX, fragY, Point1X, Point1Y, Point2X, Point2Y, Point3X, Point3Y, Point4X, Point4Y) {
        return vec4(0) // Transparent outside lane
    }
    
    // Calculate depth factor for 3D tunnel effect
    depthFactor := getDepthFactor(fragX, fragY, CenterX, CenterY)
    
    // Create strong 3D gradient - very dark at center (far), bright at edges (near)
    tunnelGradient := 0.02 + (depthFactor * depthFactor * 0.5) // Exponential falloff
    
    // Active lane illumination effect
    activeBoost := 1.0
    activePulse := 1.0
    if IsActive > 0.5 {
        activeBoost = 3.0 // Strong brightness when pressed
        // Add subtle pulse effect
        activePulse = 1.0 + (sin(fragX * 0.1 + fragY * 0.1) * 0.1)
    }
    
    // Create tunnel wall effect - brighter at lane boundaries
    // Calculate distance to nearest lane edge for wall highlighting
    edgeDist1 := distanceToLineSegment(fragX, fragY, Point1X, Point1Y, Point2X, Point2Y)
    edgeDist2 := distanceToLineSegment(fragX, fragY, Point2X, Point2Y, Point3X, Point3Y)
    edgeDist3 := distanceToLineSegment(fragX, fragY, Point3X, Point3Y, Point4X, Point4Y)
    edgeDist4 := distanceToLineSegment(fragX, fragY, Point4X, Point4Y, Point1X, Point1Y)
    
    minEdgeDist := min(min(edgeDist1, edgeDist2), min(edgeDist3, edgeDist4))
    
    // Create wall highlight - brighter near edges for tunnel effect
    wallHighlight := 1.0 - clamp(minEdgeDist / 50.0, 0.0, 1.0) // 50px falloff from edges
    wallHighlight = wallHighlight * wallHighlight * 0.3 // Squared falloff, moderate intensity
    
    // Combine tunnel gradient with wall highlighting
    finalIntensity := (tunnelGradient + wallHighlight) * activeBoost * activePulse
    
    // Apply lane color with 3D tunnel effect
    finalR := ColorR * finalIntensity
    finalG := ColorG * finalIntensity  
    finalB := ColorB * finalIntensity
    finalA := finalIntensity * 0.6 // Overall tunnel visibility
    
    return vec4(finalR, finalG, finalB, finalA)
}

// Helper function to calculate distance from point to line segment
func distanceToLineSegment(px, py, ax, ay, bx, by float) float {
    abx := bx - ax
    aby := by - ay
    apx := px - ax
    apy := py - ay
    
    ab2 := abx*abx + aby*aby
    
    if ab2 == 0.0 {
        return sqrt(apx*apx + apy*apy)
    }
    
    t := (apx*abx + apy*aby) / ab2
    t = max(0.0, min(1.0, t))
    
    closestX := ax + t * abx
    closestY := ay + t * aby
    
    dx := px - closestX
    dy := py - closestY
    return sqrt(dx*dx + dy*dy)
}